input {
    beats {
        port => 5045
        host => "0.0.0.0"
        ssl => true
        ssl_certificate => "/etc/logstash/certs/instance/instance.crt"
        ssl_key => "/etc/logstash/certs/logstash.pkcs8.key"
    }
}

filter {
  if [infralogtype] == "zsh" {
    grok {
      match => { "message" => "^%{SYSLOGTIMESTAMP:syslog_timestamp}\s%{HOSTNAME}\s.+?:\s(?<json_message>.*)$"}
      add_field => [ "received_at", "%{@timestamp}" ]
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    json {
      source => "json_message"
    }
    ruby {
      init => "require 'base64'"
      code => 'event.set("[command]", event.get("b64_command") ? Base64.decode64(event.get("b64_command")) : nil)'
    }
    ruby {
        path => "/etc/logstash/rb/parse_cmd.rb"
        script_params => {
            "command" => "command"
        }
    }
    ruby {
        path => "/etc/logstash/rb/context_mapping.rb"
        script_params => {
            "id_tool" => "PARSED_TOOL"
            "id_params" => "PARSED_TOOL_PARAMETERS"
            "is_sudo" => "IS_SUDO"
            "id_nonparams" => "PARSED_TOOL_NON_PARAMETERS"
            # "mitre_db" => {
            #   # kerbrute, enum4linux, smbmap, mimikatz, crontab, sqlmap
            #     "reconnaissance" => ["nmap", "dig"]
            #     "discovery" => ["nmap"]
            #     "initial access" => ["sqlmap"]
            #     "execution" => []
            #     "persistence" => []
            #     "privilege escalation" => ["mimikatz"]
            #     "command control" => []
            # }
        }
    }
    # prune {
    #   whitelist_names => ["host", "user", "received_at", "infralogtype", "pid", "path", "command", "status", "IS_SUDO","PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "MITRE_MAPPING"]
    #   blacklist_name => ["json_message", "message", "b64_command"]
    # }
  }
  else if [infralogtype] == "zeek" {
    json {
      source => "message"
    } 
  }
  else if [infralogtype] == "keylogger" { 
    ruby {
        path => "/etc/logstash/rb/keylog_parse.rb"
        script_params => {
          "keystrokes" => "message"
          "tools" => ["nmap"]
        }
    }
  }
  else {
  }
}

output {
  if [@metadata][pipeline] {
    elasticsearch {
      hosts => ["0.0.0.0:9200"]
      manage_template => false
      index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
      pipeline => "%{[@metadata][pipeline]}" 
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
      sniffing => true
    }
  }
  if [infralogtype] == "zsh" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "zsh-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
    file {
      path => "/var/log/logstash/red_commands-%{+YYYY-MM-dd}.log"
      codec => "json"
      # codec => line {
      #   format => '{}'
      # }
    }
    # csv {
    #   path => "/var/log/logstash/red_commands-%{+YYYY-MM-dd}.csv"
    #   csv_options => {
    #     "col_sep" => ","
    #     "row_sep" => "\r\n"
    #   }
    # }
  }
  if [infralogtype] == "zeek" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "zeek-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
  }
  if [infralogtype] == "keylogger" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "keylogger-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
    file {
      path => "/var/log/logstash/red_keylogger-%{+YYYY-MM-dd}.log"
      codec => "json"
      # codec => line {
      #   format => '{}'
      # }
    }
    # csv {
    #   path => "/var/log/logstash/red_keylogger-%{+YYYY-MM-dd}.csv"
    #   csv_options => {
    #     "col_sep" => ","
    #     "row_sep" => "\r\n"
    #   }
    # }
  }
}
