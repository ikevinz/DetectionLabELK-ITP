input {
    beats {
        port => 5045
        host => "0.0.0.0"
        ssl => true
        ssl_certificate => "/etc/logstash/certs/instance/instance.crt"
        ssl_key => "/etc/logstash/certs/logstash.pkcs8.key"
    }
}

filter {
  if [infralogtype] == "zsh" {
    grok {
      match => { "message" => "^%{SYSLOGTIMESTAMP:syslog_timestamp}\s%{HOSTNAME:red_hostname}\s%{USERNAME:red_username}:\s(?<json_message>.*)$"}
      add_field => [ "received_at", "%{@timestamp}" ]
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    mutate {
      add_field => {
        "red_ip_address" => "%{[@metadata][ip_address]}"
        "red_input" => "None"
      }
    }
    json {
      source => "json_message"
    }
    ruby {
      init => "require 'base64'"
      code => 'event.set("[command]", event.get("b64_command") ? Base64.decode64(event.get("b64_command")) : nil)'
    }
    ruby {
        path => "/etc/logstash/rb/parse_cmd.rb"
        script_params => {
            "command" => "command"
        }
    }
    ruby {
        path => "/etc/logstash/rb/context_mapping.rb"
        script_params => {
            "id_tool" => "PARSED_TOOL"
            "id_params" => "PARSED_TOOL_PARAMETERS"
            "is_sudo" => "IS_SUDO"
            "id_nonparams" => "PARSED_TOOL_NON_PARAMETERS"
        }
    }
    # prune {
    #   whitelist_names => ["host", "user", "received_at", "infralogtype", "pid", "path", "command", "status", "IS_SUDO","PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "MITRE_MAPPING"]
    #   blacklist_name => ["json_message", "message", "b64_command"]
    # }
  }
  else if [infralogtype] == "bash" {
    grok {
      match => { "message" => "^%{SYSLOGTIMESTAMP:syslog_timestamp}\s%{HOSTNAME:red_hostname}\s%{USERNAME:red_username}:\s(?<json_message>.*)$"}
      add_field => [ "received_at", "%{@timestamp}" ]
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    mutate {
      add_field => {
        "red_ip_address" => "%{[@metadata][ip_address]}"
        "red_input" => "None"
      }
    }
    json {
      source => "json_message"
    }
    ruby {
      init => "require 'base64'"
      code => 'event.set("[command]", event.get("b64_command") ? Base64.decode64(event.get("b64_command")) : nil)'
    }
    ruby {
        path => "/etc/logstash/rb/parse_cmd.rb"
        script_params => {
            "command" => "command"
        }
    }
    ruby {
        path => "/etc/logstash/rb/context_mapping.rb"
        script_params => {
            "id_tool" => "PARSED_TOOL"
            "id_params" => "PARSED_TOOL_PARAMETERS"
            "is_sudo" => "IS_SUDO"
            "id_nonparams" => "PARSED_TOOL_NON_PARAMETERS"
        }
    }
  else if [infralogtype] == "zeek" {
    json {
      source => "message"
    } 
  }
  else if [infralogtype] == "keylogger" { 
    grok {
      match => { "message" => "^%{SYSLOGTIMESTAMP:syslog_timestamp}\s%{HOSTNAME:red_hostname}\s%{USERNAME:red_username}:\s(?<red_input>.*)$"}
      add_field => [ "received_at", "%{@timestamp}" ]
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    mutate {
      add_field => {
        "red_ip_address" => "%{[@metadata][ip_address]}"
        "path" => "None"
        "command" => "None"
        "status" => "None"
      }
    }
    ruby {
        path => "/etc/logstash/rb/keylog_parse.rb"
        script_params => {
          "keystrokes" => "red_input"
          "tools" => ["nmap"]
        }
    }
  }
  else {
  }
}

output {
  if [@metadata][pipeline] {
    elasticsearch {
      hosts => ["0.0.0.0:9200"]
      manage_template => false
      index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
      pipeline => "%{[@metadata][pipeline]}" 
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
      sniffing => true
    }
  }
  if [infralogtype] == "zsh" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "zsh-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
    csv {
      path => "/var/log/logstash/red_machines/%{[@metadata][ip_address]}/%{[@metadata][ip_address]}-commands-%{+YYYY-MM-dd}.csv"
      fields => ["syslog_timestamp", "red_ip_address", "red_hostname", "red_username", "infralogtype", "path", "command", "status", "red_input", "IS_SUDO", "PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "TARGETED_FILEPATHS", "TARGETED_MACHINES", "MITRE_MAPPING"]
      # fields => ["@timestamp", "red_ip_address", "agent.hostname", "user", "path", "command", "status", "PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "TARGETED_FILEPATHS", "TARGETED_MACHINES"]
    }
  }
  if [infralogtype] == "bash" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "bash-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
    csv {
      path => "/var/log/logstash/red_machines/%{[@metadata][ip_address]}/%{[@metadata][ip_address]}-commands-%{+YYYY-MM-dd}.csv"
      fields => ["syslog_timestamp", "red_ip_address", "red_hostname", "red_username", "infralogtype", "path", "command", "status", "red_input", "IS_SUDO", "PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "TARGETED_FILEPATHS", "TARGETED_MACHINES", "MITRE_MAPPING"]
      # fields => ["@timestamp", "red_ip_address", "agent.hostname", "user", "path", "command", "status", "PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "TARGETED_FILEPATHS", "TARGETED_MACHINES"]
    }
  }
  if [infralogtype] == "zeek" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "zeek-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
  }
  if [infralogtype] == "keylogger" {
    elasticsearch{
      hosts => ["0.0.0.0:9200"]
      sniffing => true
      index => "keylogger-%{+YYYY.MM.dd}"
      ssl => true
      ssl_certificate_verification => false
      cacert => '/etc/logstash/certs/logstash.pem'
    }
    # file {
    #   path => "/var/log/logstash/red_keylogger-%{+YYYY-MM-dd}.log"
    #   codec => "json"
    #   # codec => line {
    #   #   format => '{}'
    #   # }
    # }
    csv {
      path => "/var/log/logstash/red_machines/%{[@metadata][ip_address]}/%{[@metadata][ip_address]}-commands-%{+YYYY-MM-dd}.csv"
      fields => ["syslog_timestamp", "red_ip_address", "red_hostname", "red_username", "infralogtype", "path", "command", "status", "red_input", "IS_SUDO", "PARSED_TOOL", "PARSED_TOOL_PARAMETERS", "PARSED_TOOL_NON_PARAMETERS", "TARGETED_FILEPATHS", "TARGETED_MACHINES", "MITRE_MAPPING"]
    }
  }
}
